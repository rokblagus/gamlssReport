gamlss.pb
function (x, y, w, xeval = NULL, ...) 
{
  regpen <- function(y, X, w, lambda, D) {
    RD <- rbind(R, sqrt(lambda) * D)
    svdRD <- svd(RD)
    rank <- sum(svdRD$d > max(svdRD$d) * .Machine$double.eps^0.8)
    U1 <- svdRD$u[1:p, 1:rank]
    y1 <- t(U1) %*% Qy
    beta <- svdRD$v[, 1:rank] %*% (y1/svdRD$d[1:rank])
    HH <- (svdRD$u)[1:p, 1:rank] %*% t(svdRD$u[1:p, 1:rank])
    df <- sum(diag(HH))
    fit <- list(beta = beta, edf = df)
    return(fit)
  }
  fnGAIC <- function(lambda, k) {
    fit <- regpen(y = y, X = X, w = w, lambda = lambda, D)
    fv <- X %*% fit$beta
    GAIC <- sum(w * (y - fv)^2) + k * fit$edf
    GAIC
  }
  fnGCV <- function(lambda, k) {
    I.lambda.D <- (1 + lambda * UDU$values)
    edf <- sum(1/I.lambda.D)
    y_Hy2 <- y.y - 2 * sum((yy^2)/I.lambda.D) + sum((yy^2)/((I.lambda.D)^2))
    GCV <- (n * y_Hy2)/(n - k * edf)^2
    GCV
  }
  edf1_df <- function(loglambda) {
    lambda <- exp(loglambda)
    I.lambda.D <- (1 + lambda * UDU$values)
    edf <- sum(1/I.lambda.D)
    (edf - df)
  }
  edf2_df <- function(loglambda) {
    lambda <- exp(loglambda)
    I.lambda.D <- (1 + lambda * UDU$values)
    edf <- sum(1/I.lambda.D)
    (edf - max.df)
  }
  if (is.null(xeval)) {
    X <- if (is.null(xeval)) 
      as.matrix(attr(x, "X"))
    else as.matrix(attr(x, "X"))[seq(1, length(y)), 
                                 ]
    Name <- as.character(attr(x, "Name"))
    D <- as.matrix(attr(x, "D"))
    lambda <- as.vector(attr(x, "lambda"))
    df <- as.vector(attr(x, "df"))
    max.df <- as.vector(attr(x, "max.df"))
    control <- as.list(attr(x, "control"))
    gamlss.env <- as.environment(attr(x, "gamlss.env"))
    startLambdaName <- as.character(attr(x, "NameForLambda"))
    order <- control$order
    N <- sum(w != 0)
    n <- nrow(X)
    p <- ncol(D)
    qrX <- qr(sqrt(w) * X, tol = .Machine$double.eps^0.8)
    R <- qr.R(qrX)
    Q <- qr.Q(qrX)
    Qy <- t(Q) %*% (sqrt(w) * y)
    tau2 <- sig2 <- NULL
    lambdaS <- get(startLambdaName, envir = gamlss.env)
    if (lambdaS >= 1e+07) 
      lambda <- 1e+07
    if (lambdaS <= 1e-07) 
      lambda <- 1e-07
    if (is.null(df) && !is.null(lambda) || !is.null(df) && 
        !is.null(lambda)) {
      fit <- regpen(y, X, w, lambda, D)
      fv <- X %*% fit$beta
    }
    else if (is.null(df) && is.null(lambda)) {
      lambda <- lambdaS
      switch(control$method, ML = {
        for (it in 1:50) {
          fit <- regpen(y, X, w, lambda, D)
          gamma. <- D %*% as.vector(fit$beta)
          fv <- X %*% fit$beta
          sig2 <- sum(w * (y - fv)^2)/(N - fit$edf)
          tau2 <- sum(gamma.^2)/(fit$edf - order)
          if (tau2 < 1e-07) tau2 <- 1e-07
          lambda.old <- lambda
          lambda <- sig2/tau2
          if (lambda < 1e-07) lambda <- 1e-07
          if (lambda > 1e+07) lambda <- 1e+07
          if (abs(lambda - lambda.old) < 1e-07 || lambda > 
              1e+10) break
          assign(startLambdaName, lambda, envir = gamlss.env)
        }
      }, GAIC = {
        lambda <- nlminb(lambda, fnGAIC, lower = 1e-07, 
                         upper = 1e+07, k = control$k)$par
        fit <- regpen(y = y, X = X, w = w, lambda = lambda, 
                      D)
        fv <- X %*% fit$beta
        assign(startLambdaName, lambda, envir = gamlss.env)
      }, GCV = {
        wy <- sqrt(w) * y
        y.y <- sum(wy^2)
        Rinv <- solve(R)
        S <- t(D) %*% D
        UDU <- eigen(t(Rinv) %*% S %*% Rinv)
        yy <- t(UDU$vectors) %*% Qy
        lambda <- nlminb(lambda, fnGCV, lower = 1e-07, 
                         upper = 1e+07, k = control$k)$par
        fit <- regpen(y = y, X = X, w = w, lambda = lambda, 
                      D)
        fv <- X %*% fit$beta
        assign(startLambdaName, lambda, envir = gamlss.env)
      })
      if (fit$edf > max.df) {
        Rinv <- try(solve(R), silent = TRUE)
        if (any(class(Rinv) %in% "try-error")) 
          stop("The B-basis for ", Name, " is singular, transforming the variable may help", 
               "\n")
        S <- t(D) %*% D
        UDU <- eigen(t(Rinv) %*% S %*% Rinv, symmetric = TRUE, 
                     only.values = TRUE)
        loglambda <- if (sign(edf2_df(-30)) == sign(edf2_df(30))) 
          30
        else uniroot(edf2_df, c(-30, 30))$root
        lambda <- exp(loglambda)
        fit <- regpen(y, X, w, lambda, D)
        if (abs(fit$edf - max.df) > 0.1) 
          warning("the target df's are not acheived, try to reduce the no. of knot intervals \n in pb(). eg. inter=10")
        fv <- X %*% fit$beta
        assign(startLambdaName, lambda, envir = gamlss.env)
      }
    }
    else {
      Rinv <- try(solve(R), silent = TRUE)
      if (any(class(Rinv) %in% "try-error")) 
        stop("The B-basis for ", Name, " is singular, transforming the variable may help", 
             "\n")
      S <- t(D) %*% D
      UDU <- eigen(t(Rinv) %*% S %*% Rinv, symmetric = TRUE, 
                   only.values = TRUE)
      loglambda <- if (sign(edf1_df(-30)) == sign(edf1_df(30))) 
        30
      else uniroot(edf1_df, c(-30, 30))$root
      lambda <- exp(loglambda)
      fit <- regpen(y, X, w, lambda, D)
      if (abs(fit$edf - df) > 0.1) 
        warning("the target df's are not acheived, try to reduce the no. of knot intervals \n in pb(). eg. inter=10")
      fv <- X %*% fit$beta
    }
    waug <- as.vector(c(w, rep(1, nrow(D))))
    xaug <- as.matrix(rbind(X, sqrt(lambda) * D))
    lev <- hat(sqrt(waug) * xaug, intercept = FALSE)[1:n]
    lev <- (lev - .hat.WX(w, x))
    var <- lev/w
    suppressWarnings(Fun <- splinefun(x, fv, method = "natural"))
    coefSmo <- list(coef = fit$beta, fv = fv, lambda = lambda, 
                    edf = fit$edf, sigb2 = tau2, sige2 = sig2, sigb = if (is.null(tau2)) NA else sqrt(tau2), 
                    sige = if (is.null(sig2)) NA else sqrt(sig2), method = control$method, 
                    name = Name, knots = attr(X, "knots"), fun = Fun)
    class(coefSmo) <- "pb"
    list(fitted.values = fv, residuals = y - fv, var = var, 
         nl.df = fit$edf - 2, lambda = lambda, coefSmo = coefSmo)
  }
  else {
    position <- 0
    rexpr <- regexpr("predict.gamlss", sys.calls())
    for (i in 1:length(rexpr)) {
      position <- i
      if (rexpr[i] == 1) 
        break
    }
    gamlss.environment <- sys.frame(position)
    param <- get("what", envir = gamlss.environment)
    object <- get("object", envir = gamlss.environment)
    TT <- get("TT", envir = gamlss.environment)
    smooth.labels <- get("smooth.labels", envir = gamlss.environment)
    pred <- getSmo(object, parameter = param, which = which(smooth.labels == 
                                                              TT))$fun(xeval)
    pred
  }
}


gt<-function (x, z)   .Call(C_SplineEval, x, z)

getSmo
function (object, what = c("mu", "sigma", "nu", 
                           "tau"), parameter = NULL, which = 1) 
{
  if (!is.gamlss(object)) 
    stop("this is design for gamlss objects only")
  what <- if (!is.null(parameter)) {
    match.arg(parameter, choices = c("mu", "sigma", 
                                     "nu", "tau"))
  }
  else match.arg(what)
  if (!what %in% object$par) 
    stop(paste(what, "is not a parameter in the object", 
               "\n"))
  AllSmo <- object[[paste(what, ".coefSmo", sep = "")]]
  Smo <- if (which == 0) 
    AllSmo
  else AllSmo[[which]]
  Smo
}


